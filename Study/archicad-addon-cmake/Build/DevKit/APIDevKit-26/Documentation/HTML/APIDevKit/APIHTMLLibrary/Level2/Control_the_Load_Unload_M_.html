<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
    <title>Control the Load/Unload Mechanism</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta http-equiv="Content-Language" content="en-US">
    <meta name="Author" content="GRAPHISOFT SE">
    <link rel="stylesheet" type="text/css" href="../../StyleLibrary/Style.css">
    <script type="text/javascript" src="../../StyleLibrary/Java.js"></script>
    <script type="text/javascript" src="../../StyleLibrary/TOCscript.js"></script>
    <script type="text/javascript">
      LEVELSTR = "../../";
      ICONPATH = LEVELSTR + "StyleLibrary/Images/Treeview/";
    </script>
    <script type="text/javascript" src="../../StyleLibrary/TOC.js"></script>
    <script type="text/javascript" src="../../StyleLibrary/tree_tpl.js"></script>
    <script type="text/javascript" src="../../StyleLibrary/tree.js"></script>
    <meta name="Microsoft.Help.F1" content="APIHTMLLibrary/Level2/Control_the_Load_Unload_M_.html">
    <xml>
      <MSHelp:Attr Name = "DocSet" Value = "Graphisoft"/>
    </xml>
</head>
<body>
<div id="docBegin">
  <p id="graphisoft_title">&nbsp;<span>Graphisoft&reg;</span></p>
  <p class="hdr"><span class="TitleMain">API&nbsp;Development&nbsp;Kit</span><span class="TitleVersion">Version: 26</span></p>
</div>
<div id="content" class="inset">
          <script type="text/javascript">
            insertTOC ();
          </script>


    <h1>Control the Load/Unload Mechanism</h1>

    <p>&nbsp;<br>
    Remember that every add-on is a DLL on the Windows, and a Mach-O bundle on the Macintosh. If the user invokes any of the add-on commands, the add-on is loaded into memory, then the appropriate command is executed and finally the add-on is purged from the memory.</p>

    <h4>The default calling mechanism</h4>

    <p><img border="0" src="../../APIImageLibrary/14.png" alt="Modified in 14" width="19" height="12">&nbsp;The startup mechanism has changed significantly in Archicad 14. This enables a much faster startup of Archicad.</p>

    <ul>
        <li>the Add-On Manager loads the add-on, and</li>

        <li style="list-style: none; display: inline">
            <ul>
                <li>calls its <a href="../Functions/CheckEnvironment.html">CheckEnvironment</a> function, then</li>

                <li>calls its <a href="../Functions/RegisterInterface.html">RegisterInterface</a> function</li>
            </ul>
        </li>

        <li>the add-on is unloaded if it doesn't have to be preloaded/kept in memory</li>

        <li style="list-style: none"><br>
        &nbsp;</li>

        <li>user request</li>

        <li>the add-on is loaded into the memory if necessary

            <ul>
                <li>the <a href="../Functions/Initialize.html">Initialize</a> function is called</li>

                <li>the appropriate handler function is called</li>

                <li>the <a href="../Functions/FreeData.html">FreeData</a> function is called</li>
            </ul>
        </li>

        <li>the add-on is unloaded if doesn't have to be kept in memory</li>
    </ul>

    <p>This default scheme is quite inconvenient if the functionality needs a complex initialization/termination procedure. Suppose that an add-on is working on an external database too. If the user needs any information stored in that database, first it must be initialized, then the links must be set up to the Archicad database. It can take a significant amount of time.</p>

    <p>A better solution can be if the add-on can initialize itself only once, no matter how many user commands are invoked. Of course, it can be implemented if your add-on is kept in the memory between several user interactions only. This is the only way to preserve the initialized global variables, dynamic memory blocks, etc.</p>

    <p>The solution is to call the <a href="../Functions/ACAPI_KeepInMemory.html">ACAPI_KeepInMemory</a> function, while any of the handler functions are executed. Some operations (e.g. when an add-on has its own palette, or registers a notification handler) cause the add-on to stay in memory without calling this function.</p>

    <p>In this case the add-on will NOT be UNLOADED from the memory upon return from the callback function. The add-on remains loaded, which means that the <code>FreeData</code> function will not be called, of course. In this case it is not necessary to load the add-on into the memory upon the next user request, so the <code>Initialize</code> function will not be called also that time. The server application keeps calling the registered callback function(s) only.</p>

    <p>The rules are very easy:</p>

    <ul>
        <li>the <a href="../Functions/Initialize.html">Initialize</a> function is called just after the add-on is loaded into the memory physically,</li>

        <li>the appropriate callback function is called when the Initialize function has been executed and returns successfully,</li>

        <li>the <a href="../Functions/FreeData.html">FreeData</a> function is called just before the add-on must be swapped out.<br>
        An add-on must be unloaded when the last handler function has not called the <a href="../Functions/ACAPI_KeepInMemory.html">ACAPI_KeepInMemory</a> function, all the palettes have been dismissed, all the registered notification handlers has been unregistered..</li>
    </ul>

    <p><i>Note:</i> if you have global variables, they will be initialized each time the add-on is loaded, and destroyed each time the add-on is unloaded. This may mean three initialization and termination sequences for a simple add-on command. This can have severe impact on your add-on's performance and on the startup time of the server application, especially if you have instances of complex C++ classes as global variables. Also, the API (and most other modules') services are not available during the construction and destruction of these global variables, so e.g. you cannot use the BM Memory Manager there. This lead to nice crashes in the past; the solution is to use only pointers, and construct the global instances only in your initialize function.</p>

    <p>&nbsp;</p>

    <h4>The controlled calling mechanism</h4>

    <p>According to the above rules you can prevent yourself unloading from the memory by the server application.</p>

    <ul>
        <li>user request</li>

        <li>the add-on is loaded into the memory

            <ul>
                <li><code>Initialize</code> is called</li>

                <li>a handler function is called

                    <ul>
                        <li><code>ACAPI_KeepInMemory</code> called by the add-on</li>
                    </ul>
                </li>
            </ul>
        </li>

        <li>user request

            <ul>
                <li>a handler function is called

                    <ul>
                        <li><code>ACAPI_KeepInMemory</code> called by the add-on</li>
                    </ul>
                </li>
            </ul>
        </li>

        <li>user request

            <ul>
                <li>a handler function is called

                    <ul>
                        <li><code>ACAPI_KeepInMemory</code> called by the add-on</li>
                    </ul>
                </li>
            </ul>
        </li>

        <li>user request

            <ul>
                <li>a handler function is called</li>

                <li><code>FreeData</code> is called</li>
            </ul>
        </li>

        <li>the add-on is unloaded</li>
    </ul>

    <p>&nbsp;</p>

    <h4>Important</h4>

    <p>You may have serious problems, if you use this feature without enough care.</p>

    <p>An example: You initialize your data structure according to the actual Archicad database. Your code is kept in the memory, but between two commands the user opens an other Archicad project, or closes the active one, etc. Such cases result that your initialization may became completely invalid.</p>

    <p>To control these events, you must handle the notification codes sent by Archicad. They are documented in the <a href="../Level3/notification_manager_id.html">Notification Manager</a>. By tracking these notification codes, you will be informed by Archicad if the user opens a new project, closes the active one, creates a completely new one and even if the user quits Archicad.</p>

    <p>&nbsp;</p>

    

</div>
<div id="footer">
    <p class="hdr1">      <span class="Credits">Copyright &copy; 2022 - GRAPHISOFT SE. All rights reserved worldwide. <br />Modified on March 5, 2010<br/>
      </span>
    </p>
    <p id="toplink"><a href="#docBegin"><img src="../../StyleLibrary/Images/top.gif" alt="top" width="31" height="14" id="toTopImg" /></a></p>
</div>
</body>
</html>
